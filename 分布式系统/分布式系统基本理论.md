[TOC]

## 1 CAP理论

- 数据一致性（consistency）：如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个数据；如果返回失败，那么所有读操作都不能读到这个数据，对调用者而言数据具有强一致性。

- 服务可用性（availablility）：所有读写请求在一定时间内得到响应，可终止不会一直等待。

- 分区容错（partition-tolerance）：在网络分区的情况下，被分隔节点仍能正常对外服务。

  如果选择了 **CA** 而放弃了 **P** ，那么在发生分区现象时，为了保证 **C** ，系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 **A** 发生了冲突，因为 **A** 要求返回 no error 和 no timeout 。因此，分布式理论不能选择 **CA** 架构，只能选择 **CP** 或者 **AP**。

  

**反证：**

如果 **CAP** 三者同时满足，由于允许 **P** 的存在，则一定存在节点之间的丢包，如此则不能保证 **C**。

因为允许分区容错，写操作可能在节点1上成功，在节点2上失败，这时候对于client1（读取节点1）和client2（读取节点2），就会读取到不一致的值，出现不一致的情况。如果要保持一致性，写操作必须同时失败，也就是降低系统的可用性。

## 2 Base理论

cap理论的一种妥协，由于cap只能二取其一，base理论降低了发生分区容错时对可用性和一致性的要求。

1. 基本可用：允许可用性降低（可能响应延长、可能服务降级（例如，网络不顺畅时，图片信息暂时不显示））
2. 软状态：只允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体的可用性（比如在支付时，就存在支付中这个状态，提供缓冲时间）。
3. 最终一致性：节点数据同步可以存在延时，但在一定期限后必须达成数据一致性，状态变为最终状态。

## 3 数据一致性模型

- 强一致性：当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户最友好的。根据CAP理论，这种实现方式需要牺牲服务的可用性。
- 弱一致性：系统在数据写入成功后，不承诺立即可以读到最新写入的数据，也不会承诺多久之后可以读到。用户读到某一操作对系统数据的更新需要一段时间，我们称这一段时间为“不一致窗口”。
- 最终一致性：最终一致性为弱一致性的特例。强调的时所有数据副本，在经过一段时间的同步后，最终都能够达到一个一致的状态。因此，最终一致性的本质时保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。
- 因果一致性：要求有因果关系的操作顺序要得到保证，非因果关系的操作顺序则无所谓。
- 会话一致性：将系统数据的访问过程框定在一个会话中，约定了系统能保证同一个有效的会话中实现“读已知所写”的一致性，就是在你的一次访问中，执行更新操作之后，客户端能在同一个会话中始终读取到该数据的最新值。实际开发中又分布式的session一致性问题。

## 4 选举算法Quorum机制、WARO协议

- waro：一种简单的副本控制协议，写操作时，只有当所有的副本更新成功之后，这次写操作才算成功，否则视为失败。优先保证读、任何节点读到的数据都是最新数据，牺牲了更新服务的可用性，只要有一个副本宕机了，写服务就不会成功。但只要有一个节点存活，仍能提供读服务。
- Quorum机制：10个副本，一次更新了3个（假设只要更新3个就算写成功），那么至少需要读取8个副本的数据（10-3+1），可以保证读到了最新的数据。无法保证强一致性，也就是无法实现任何时刻任何用户都可以读到最近一次成功提交的副本数据。需要配合一个获取最新成功提交的版本号的 metadata 服务（版本号最大的那个），这样可以确定最新已经成功提交的版本号，然后从已读到的数据中就可以确定最新写入的数据。

## 5 Paxos算法（共识算法）

### 5.1 basic-paxos

Paxos算法解决的是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各个节点的初始状态一致，每个节点执行相同的操作序列（包括操作指令和操作顺序），那么他们最后能够得到一个一致的状态。为了保证每个节点执行相同的操作序列，需要在每一条指令上执行一个 “一致性算法” 以保证每个节点看到的指令一致。在Paxos算法中，有三种角色：Proposer（提议者），Acceptor（接受者），Learners（记录员）。

- Proposer（提议者）：只要 Proposer 发的提案被半数以上的 Acceptor 接受，Proposer 就认为提案的 value 被选定了。
- Acceptor（接受者）：只要 Acceptor 接受了某个提案，Acceptor 就认为提案的 value 被选定了。
- Learners（记录员）：Acceptors 告诉 Learner 哪个 value 被选定，Learner就认为哪个 value 被选定。



Paxos算法分为两个阶段，具体如下：

**阶段一（prepare）：**

1. Proposer 收到 client 请求或者发现本地有未提交的值，选择一个提案编号 N ，然后向半数以上的 Acceptor 发送编号 N 的 Prepare 请求。
2. Acceptor 收到一个编号为 N 的 prepare 请求，如果该轮 paxos （一轮只保证一个值）
   - 本节点已经有已提交的 value 记录（已经持久化的记录，记录了编号字段），对比记录的编号和 N ，大于 N 则拒绝回应（相当于拒绝投票），否则返回该记录 value 及编号。
   - 没有已提交记录，判断本地是否有编号 N1 ，N1>N 则拒绝回应，否则将 N1 改为 N （如果没有 N1 ，则记录 N） ，并响应 prepare。

**阶段二（accept）：**

1. 如果 Proposer 收到了半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么他就会发送一个针对 [N, V] 提案的 Accept 请求给半数以上的 Acceptor 。V 就是收到的响应中编号最大的 value ，如果响应中不包含任何 value ，那么 V 就有 Proposer 自己决定（需要优先同步已经持久化的记录！！）。
2. 如果 Acceptor 收到一个针对 N 的提案的 Accept 请求，Acceptor 对比本地的记录编号，如果小于等于 N ，则接受该值，并提交记录 value 。否则拒绝。

Proposer 如果收到大多数 Acceptor 响应，则选择该 value 值，并同步给 Learner，使未响应的 Acceptor 达成一致。

![image-20221013212107000](.\分布式系统基本理论.assets\image-20221013212107000.png)

**basic-paxos缺点：**

1. 活锁：accept时被拒绝，加大 N 重新 accept，此时另外一个 proposer 也进行相同的操作（两个角色会一直累加N），导致 accept 一致失败，无法完成算法。
2. 准备阶段和接受阶段实际上是两轮RPC通信，在往返消息多的情况下，有可能造成大量延迟。

### 5.2 multi-paxos

为了解决上述问题，引入了一个新的角色节点，领导者（Leader）,把它作为唯一提议者，这样就不存议案提交冲突的问题了（Leader的选举需要自己实现）。接下来，就该考虑如何优化Basic Paxos，一般考虑省掉准备阶段，直接进入接受阶段。这样，领导者的节点，命令是最新的，不再需要通过准备请求来发现之前被大多数节点通过的议案。领导者可以独立地指定议案中的值（V）。这样就可以直接进入接受阶段了。



## 6 raft算法

### 6.1 概念

- 分布式一致性算法：raft 会先选出 leader ，leader 完全负责 replicated log （日志副本）的管理。leader 负责接受所有客户端请求，然后复制到 follower 节点，并在 “安全” 的时候执行这些请求。如果 leader 节点故障，followers 会重新选举出 leader。
- 三种状态：
  - leader：处理所有的客户端请求（如果客户端将请求发给了 follower ，follower 将请求重定向给 leader）。
  - follower：不会发送任何请求，指挥简单的响应来自 leader 或 candidate 的请求。
  - candidate（候选人）：用于选举产生新的 leader。
- term（任期）：leader 产生到重新选举为一任期，每个节点都维持者当前的任期号。
  - term是递增的，存储在 log 日志的 entry 中，代表当前 entry 是在哪一个 term 时期写入。
  - 每个任期只能由一个 leader 或者没有（选举失败）。
  - 每次 rpc 通信时传递该任期号，如果 rpc 收到任期号大于本地的，切换为 follower ，小于本地任期号则返回错误信息。
- 两个 rpc 通信：
  - RequestVote RPC：负责选举，包含参数 lastindex，lastterm。
  - AppendEntries RPC：负责数据交互。
- 日志序列：每个节点上维持着一份持久化 log ，通过一致性算法，保证每一个节点中的 log 保持一致，并且顺序存放，这样客户端就可在每一个节点上读取到相同的数据。
- 状态机：日志序列同步到多数节点，leader 将该日志提交到状态机，并在下一次心跳通知所有节点提交状态机（携带最后提交的 lastindex）。



**何时触发选举：**

- 集群初始化时，都是 follower ，随机超时，编程candidate ，发起选举。
- 如果 follower 在 election timeout 内没有收到来自 leader 的心跳，则主动触发选举。

**选举过程（发出选举的角度）：**

1. 

 